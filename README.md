# W5500

Данная библиотека предназначена для работы с Ethernet чипом W5500. Она позволяет быстро настроить
чип под выполнение базовых функций принятия и отправки данных. В неё входят все необходимые
функции чтения/записи регистров и структуры. Все они имеют префикс W5500 в названии.
Принципиально чип W5500 делится на две основные области – это главный регистр и регистры сокетов.
Главный регистр один и хранит в себе основную информацию: IP, mac, маска подсети, адрес шлюза и т.д.
Сокетов на данной модели 8, каждый из них может работать параллельно с другими. У каждого сокета
задаётся: объём памяти буфера принятия и отправки данных, порт, режим работы с пакетами UDP или TCP и т.д.
Далее будут описаны структуры, функции и алгоритмы использования без углубления в техническую составляющую
в большинстве случаев. Более подробные характеристики по W5500 смотрите в документации производителя.

## Структуры и маска прерывания  

### W5500_buf_size - список возможных вариаций размера буфера

  ```c++
    enum W5500_buf_size {
      W5500_empty      = 0,  // пустой
      W5500_two_kb     = 2,  // 2 килобайта
      W5500_four_kb    = 4,  // 4 килобайта
      W5500_eight_kb   = 8,  // 8 килобайт
      W5500_sixteen_kb = 16  // 16 килобайт, максимальный размер
    }
  ```

### W5500_Socket – структура с основными регистрами сокетов, содержит в себе

- `Num` - Номер сокет, отсчёт идёт от 0 до 7
- `Mode` - Режим работы сокета, UDP или TCP
- `Status` – Последний статус сокета, о нём далее будет сказано
- `Last interrupt` – Последнее прерывание, подробнее в разделе прерываний
- `Port` – Порт сокета, каждый сокет может иметь свой порт
- `RX buf size` - Размер буфера приёма данных, размер может быть только вариантом из списка `W5500_buf_size`
- `TX buf size` - Размер буфера отправки данных, размер может быть только вариантом из списка `W5500_buf_size`
- `TX rd p`, `TX wr p`, `RX rd p`, `RX wr p` - указатели на точки начала чтения и записи.
      НЕ МЕНЯЙТЕ их без знания технической документации! За более подробной информацией
      обратитесь к даташиту.
- `Keep alive timer` - Время между отправками служебного пакета, подтверждающего
      наличие TCP соединения клиента с сервером. Считается как 5s * ваше число
- `Dipr` - IP получателя, может быть изменён при отправке данных серверу
- `Dport` - порт получателя, может быть изменён при отправке данных серверу

### W5500_User_Funcs – структура содержащая пользовательские функции И массив из 8 сокетов

- `W5500_SPI transmit func` – Пользовательская функция отправки данных через SPI.
      Её сигнатура:

     ```c++
     (const uint8_t* data, uint16_t len)
     ```

- `W5500_SPI receive func` - Пользовательская функция принятия данных через SPI.
      Её сигнатура:

     ```c++
     (uint8_t* buffer, uint16_t len)
     ```

- `W5500_CS func` – Пользовательская функция Chip select, опускает и поднимает линию CS.
      Её сигнатура:

     ```c++
     (uint8_t type_operation):
     ```

     Если передаётся 1 , то линия опускается и чип “выбран”. Если передаётся 0,
     то линия поднимается и чип ”не выбран”. Другими словами 1 перед отправкой, 0 после отправки.
- `W5500_Delay func` – функция задержки, должна принимать целое значение в миллисекундах.
      Её сигнатура:

     ```c++
     (uint32_t delay)
     ```

     `delay` в <ins>миллисекундах</ins>

### W5500_User_Callbacks – структура содержащая пользовательские функции обработки 5 прерываний

- `W5500_Callback Send Ok` – прерывание на успешную отправку данных от W5500 к получателю.
- `W5500_Callback Timeout` – прерывание, происходящее при ARP `timeout` и TCP `timeout` ,
      когда устройство не получает ответа от удаленного устройства в течение заданного времени.
      Задаётся через регистры RTR И RCR, по умолчанию не изменяются.
      Если вы хотите изменить время между повторными отправками и счётчиком повторных отправок,
      то используйте следующие функции:

     ```c++
     W5500_Set_RTR(uint16_t retry_time, W5500_Main_Struct* MS)
     ```

     устанавливает следующее время rtr = 100 мкс *`retry_time`.  
      __<ins>Пример:</ins>__ `retry_time` = 4000, следовательно  rtr = 100 мкс* 4000 = 400 мс

     ```c++
      uint8_t W5500_Set_RCR(uint8_t retry_count, W5500_Main_Struct* MS)
     ```

     устанавливает максимальное кол-во RTR, то есть если после retry_count ретрансляций “не был получен ответ”, то инициируется прерывание Timeout.
- `W5500_Callback Discon` – прерывание при отключении, справедливо только для TCP режима сокета
- `W5500_Callback Con` – прерывание при подключении к серверу, справедливо только для TCP режима сокета
Все вышеперечисленные функции обработки прерывания имеют следующую сигнатуру:

```c++
(W5500_Socket* socket, W5500_Main_Struct* MS)
```

- `W5500_Callback Recv` – прерывание при получении данных. Если вы выставили сокет в TCP сервер или выставили в UDP режим, и
    вам пришли данные, то вызывается прерывание Recv.  
    Его сигнатура:

   ```c++
    (uint8_t* buf, uint8_t size, W5500_Socket* socket, W5500_Main_Struct* MS)
   ```

    В теле обработчика используйте функцию:

   ```c++  
    uint16_t W5500_ReceiveData(uint8_t socket_num, uint8_t* buffer, uint16_t max_len, W5500_Main_Struct* MS)
   ```

    Она возвращает размер данных в байтах.  
    __<ins>Пример 1:</ins>__ вы передали буфер длинной в 20 байт, в результате функция вернула вам значение 15,
    следовательно в вашем буфере сейчас 15 байт информации и 5 незначащих.  
    __<ins>Пример 2:</ins>__ вы передали буфер длинной в 20 байт,
    в результате функция вернула вам значение 47, следовательно в вашем буфере 20 байт из W5500 и ещё 47-20= 27 байт не прочитаны,
    вы можете повторно вызвать эту функцию два раза и прочитать оставшиеся данные. При новом вызове вы продолжите
    читать с того места, на котором остановились в прошлый раз.

### Маска прерываний

  По  умолчанию при инициализации сокетов все прерывания становятся активными. Это не отразится негативно на работе,
  если ваш сокет в режиме TCP Сервера, то прерывание `Send Ok` не возникнет, также и наоборот с TCP клиентом и прерыванием `Recv`.
  При UDP режиме у вас могут возникнуть прерывания `Send Ok` и `Recv`, но без `Con` и `Discon`. Другими словами, хоть все прерывания и активны,
  это не значит, что при UDP режиме у вас возникнет `Con` прерывание. Однако если вы желаете строго задать маску, то вам следует:
  Подать в функцию битовую последовательность, где 1 – вкл, 0 - выкл  

  ```c++
  uint8_t W5500_Set_Sn_IMR(uint8_t socket_num, uint8_t interrupt_mask, W5500_User_Funcs* UF)
  ```

  Порядок битов и прерываний:  

- `Con`&emsp;&emsp;&emsp;&ensp;=  0b00001 0x1
- `Discon`&emsp;&emsp;=  0b00010 0x2
- `Recv`&emsp;&emsp;&emsp;=  0b00100 0x4
- `Timeout`&emsp;&ensp;=  0b01000 0x8
- `Send Ok`&emsp;&ensp;=  0b10000 0x10  
  __<int>Пример</int>__ включения всех прерываний:&emsp;&emsp;&emsp;&emsp;&nbsp;`interrupt_mask` = 0b11111 = 0x1F  
  __<int>Пример</int>__ включения только Send Ok и Discon:&emsp;`interrupt_mask` = 0b10010 = 0x12

### W5500_Main_Struct – главная структура, включающая указатели на W5500_User_Funcs и W5500_User_Callbacks

- `W5500_User_Funcs* UF` – указатель на объект структуры `W5500_User_Funcs`
- `W5500_User_Callbacks* UCb` – указатель на объект структуры `W5500_User_Callbacks`

## Основные функции

### Функция быстрой инициализации главного регистра

```c++
uint8_t W5500_QuickInit_Common(
    const uint8_t*     mac_address,     // мак адрес чипа
    const uint8_t*     ip_address,      // IP адрес чипа
    const uint8_t*     subnet_mask,     // маска подсети
    const uint8_t*     gateway_address, // адрес шлюза
    W5500_Main_Struct* MS)              // указатель на объект структуры W5500_Main_Struct
```

- Возвращает 0, если успешно. В противном случаи возвращает число, указывающее на позицию в
теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция быстрой инициализации сокета в UDP режиме

```c++
uint8_t W5500_QuickInit_UDP(
    uint8_t                socket_num,        // номер сокета, от 0 до 7
    uint16_t               src_port,          // порт сокета
    enum W5500_buf_size    tx_b_s,            // размер буфера отправки, принимает одно из значений W5500_buf_size
    enum W5500_buf_size    rx_b_s,            // размер буфера принятия, принимает одно из значений W5500_buf_size
    uint8_t                keep_alive_timer,  // не используется
    W5500_Main_Struct* MS)                    // указатель на объект структуры W5500_Main_Struct
```

  В данном режиме сокет всегда принимает входные данные  

- Возвращает 0, если успешно. В противном случаи возвращает число, указывающее на позицию в
теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция быстрой инициализации сокета в TCP режиме

```c++
uint8_t W5500_QuickInit_TCP(
    uint8_t                socket_num,          // номер сокета, от 0 до 7
    uint16_t               src_port,            // порт сокета
    enum W5500_buf_size    tx_b_s,              // размер буфера отправки, принимает одно из значений W5500_buf_size
    enum W5500_buf_size    rx_b_s,              // размер буфера принятия, принимает одно из значений W5500_buf_size
    uint8_t                keep_alive_timer,    // не используется
    W5500_Main_Struct* MS)                      // указатель на объект структуры W5500_Main_Struct
```

В данном режиме сокет по умолчанию выступает клиентом и не принимает входные данные, для перехода в режим сервера смотрите W5500_TCP_Listen

- Возвращает 0, если успешно. В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция TCP подключения, необходимо перед отправкой TCP пакетов

```c++
uint8_t W5500_TCP_Connect(
    uint8_t                socket_num,      // номер сокета
    const uint8_t*         dest_ip,         // IP адрес сервера
    uint16_t               dest_port,       // порт сервера
    W5500_Main_Struct* MS)                  // указатель на объект структуры W5500_Main_Struct
```

- Возвращает 0, если успешно. В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция отправки данных без прерывания

```c++
uint8_t W5500_SendData(
    uint8_t               socket_num,   // номер сокета
    const uint8_t*        dest_ip,      // IP адрес сервера
    uint16_t              dest_port,    // порт сервера
    const uint8_t*        data,         // указатель на данные
    uint16_t              len,          // длинна данных 
    W5500_Main_Struct* MS)              // указатель на объект структуры W5500_Main_Struct
```

Данная функция отправляет данные без пользовательской обработки прерывания `Send Ok`,
она проверяет наличие этого прерывания самостоятельно каждые 200 мс 10 раз.

- Возвращает 0 при успешной отправке. В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция отправки данных с прерываниями

```c++
uint8_t W5500_SendData_IR(
    uint8_t               socket_num,  // номер сокета
    const uint8_t*        dest_ip,     // IP адрес сервера
    uint16_t              dest_port,   // порт сервера
    const uint8_t*        data,        // указатель на данные
    uint16_t              len,         // длинна данных 
    W5500_Main_Struct* MS)             // указатель на объект структуры W5500_Main_Struct
```

Данная функция отправляет данные с учётом пользовательской обработки прерывания Send Ok и не проверяет состояние прерывания.

- Возвращает 0 при конце отправке (результат отправки проверяется в прерывании). В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.
__<ins>ВАЖНО: Перед отправкой TCP подключитесь к серверу.</ins>__

### Функция принятия данных

```c++
uint16_t W5500_ReceiveData(
    uint8_t               socket_num,    // номер сокета
    uint8_t*              buffer,        // указатель на начало буфера
    uint16_t              max_len,       // длина буфера
    uint16_t*             buffer_len,    // длинна данных в буфере W5500
    W5500_Main_Struct* MS)                // указатель на объект структуры W5500_Main_Struct
```

Данная функция принимает данные из сокета

- Возвращает 0 при успешном чтении. В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.  
После отправки проверьте `buffer_len` и `max_len`
__<ins>Пример 1:</ins>__ вы передали буфер длинной в 20 байт, в результате `buffer_len` = 15,
следовательно в вашем буфере сейчас 15 байт информации и 5 незначащих.  
__<ins>Пример 2:</ins>__ вы передали буфер длинной в 20 байт, в результате `buffer_len` = 47,
следовательно в вашем буфере 20 байт из W5500 и ещё 47-20= 27 байт не прочитаны, вы можете
повторно вызвать эту функцию два раза и прочитать оставшиеся данные.  
При новом вызове вы продолжите читать с того места, на котором остановились в прошлый раз.
Если вы не используете прерывания, то должны самостоятельно читать состояние регистра прерываний
или периодично вызывать данную функцию, пока `buffer_len` != 0.

### Функция TCP сервера

```c++
void W5500_TCP_Listen(
    uint8_t     socket_num, // номер сокета
    W5500_Main_Struct* MS); // указатель на объект структуры W5500_Main_Struct
```

Данная функция переводит сокет c режимом TCP в TCP cервер.  
__<ins>ВАЖНО: Предварительно закройте и откройте сокет, если до этого сокет был клиентом</ins>__
Если вы хотите выйти из режима TCP сервера, закройте сокет.

- Ничего не возвращает.

### Отключение клиента от вашего TCP сервера
Если клиент инициирует отключение от вашего сервера, вам необходимо отсделить это через прерывания или постоянное чтение регистра прерываний или состояний сокета. Когда вы отследили отключение клиента, необходимо вызвать функцию `W5500_TCP_Disconnect`. Когда сеанс будет завершён, сокет переходит в состояние `close`. Если вы желаете возобновить работу сервера, вам необходимо заново открыть сокет и перевести его в состояние `listen`.
__<ins>Пример обработчика прерывания `discon`</ins>__
```c++
void Discon_it(W5500_Socket *socket, W5500_Main_Struct *MS)
{
    W5500_TCP_Disconnect(socket->num, MS);
    W5500_OpenSocket(socket->num, MS);
    W5500_TCP_Listen(socket->num, MS);
    return;
}
```

### Функция открытия сокета

```c++
uint8_t W5500_OpenSocket(
    uint8_t            socket_num, // номер сокета
    W5500_Main_Struct* MS)         // указатель на объект структуры W5500_Main_Struct
```

Открывает сокет, по умолчанию после инициализации UDP или TCP сокет открыт

- Возвращает 0 при удачной отправке команды через SPI, 1 при неудачной

### Функция закрытия сокета

```c++
uint8_t W5500_CloseSocket(
    uint8_t            socket_num, // номер сокета
    W5500_Main_Struct* MS)         // указатель на объект структуры W5500_Main_Struct
```

Закрывает сокет и отчищает регистр прерываний сокета

- Возвращает 0 при удачном закрытии. В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция отключения от сервера

```c++
uint8_t W5500_TCP_Disconnect(
    uint8_t            socket_num, // номер сокета
    W5500_Main_Struct* MS)         // указатель на объект структуры W5500_Main_Struct
```

Разрывает соединение с сервером и закрывает сокет

- Возвращает 0 при удачном отключении. В противном случаи возвращает число, указывающее на позицию в теле функции где произошла ошибка. Для больших подробностей смотрите тело функции.

### Функция обработки прерываний

```c++
void W5500_IR_processing(
    uint8_t*           buf,      // указатель на буфер приём
    uint8_t            size,     // размер буфера приёма
    W5500_Main_Struct* MS)       // указатель на объект структуры W5500_Main_Struct
```

Данная функция считывает значение регистра прерываний сокетов, после проходит по всем сокетам и
обрабатывает их прерывания через пользовательские функции обработки.  
__<ins>Пример:</ins>__ вы проинициализировали сокет 3 и 4. После вы фиксируете прерывание по каналу INT чипа и
вызываете функцию `W5500_IR_processing`. Она получает от W5500 номера сокетов, на которых произошло прерывание.
После у каждого из этих сокетов (в данном случаи у 3-го или 4-го, или у обоих) берётся тип прерывания,
а после вызывается пользовательский обработчик, например обработчик
`Cb_RECV Callback_Recv(...)` для 3-го сокета и `Cb_SEND_OK Callback_Send_OK(...)` для 4-го.

- Ничего не возвращает

### Функция чтения регистра прерываний сокета

```c++
uint8_t W5500_Get_Sn_IR(
uint8_t* IR              // указатель на пользовательскую переменную
uint8_t socket_num,      // номер сокета
W5500_User_Funcs* UF)    // указатель на объект структуры W5500_User_Func
```

Данная функция позволяет вручную проверить состояние регистра прерываний конкретного сокета.  
Результат сохраняется в `IR`

- Возвращает 0 при успешном чтении или шаг ошибки в функции чтения регистров `W5500_ReadRegister`  
Порядок битов и прерываний:  
- `Con`&emsp;&emsp;&emsp;&ensp;=  0b00001 0x1
- `Discon`&emsp;&emsp;=  0b00010 0x2
- `Recv`&emsp;&emsp;&emsp;=  0b00100 0x4
- `Timeout`&emsp;&ensp;=  0b01000 0x8
- `Send Ok`&emsp;&ensp;=  0b10000 0x10  
